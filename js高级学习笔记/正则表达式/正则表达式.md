[toc]

# 正则表达式

- 是字符串匹配的利器

## 一. 简单介绍使用

```js
// 创建正则表达式: 
// 1. 构造函数: new RegExp(pattern(匹配的规则),flags(匹配的一些修饰))
// 2. 字面量: 直接写: /sssss/i   中间写规则,后面写修饰
const re1 = new RegExp("abc","ig")   //   "i"表示ignore忽略大小写, "g"表示找到所有符合的
const newMessage = message.replaceAll(re1,"cba")
```

![Snipaste_2022-12-16_22-17-41](.\图片\Snipaste_2022-12-16_22-17-41.png)

## 二. 使用正则的函数

- 这里都是实例上的方法,不是类方法

- String方法:
  - matchAll: 查找所有匹配, 返回一个迭代器(iterator), 传入的正则必须加`g`,for..of遍历
  - **match**: 在一个字符串中测试是否匹配的字符串方法,返回一个数组,没有匹配时则返回null
  - search: 返回匹配到的位置索引
  - replace: 查找匹配到的字符串并进行替换
  - split: 使用正则表达式或者字符串分割一个字符串,并将其存入一个数组中
- RegExp方法:
  - **exec**: 字符串中执行查找匹配的RegExp方法,返回一个数组(未匹配到则返回null)
  - **test:** 返回是否匹配到了,boolean



## 三. 正则匹配规则

### 1. 边界匹配

- `^`表示开头整个字符

- `$`表示结尾的整个字符

- `\b`: 匹配单词边界, `\bname\b`表示中间的`name`必须是一个单独的单词, 不能有`\w`中的字符

- `\B`: 匹配除单词边界之外的位置

### 2. 重复匹配

- `*`: 匹配前面的一个字符0次或多次
- `+`: 匹配前一个字符出现1次或多次
- `?`: 匹配前一个字符出现0次或1次
- `{x,y}`: 前一个字符或字符集出现x~y次, `/^a{5,8}$/`, {}表示5到8个
- `|`: 匹配多个模式之一

### 3. 字符匹配

- `.`: 匹配任意一个字符
- `[abc]`: 匹配a, b或c中的**一个字符**
- `[a-z]`: 匹配任意一个小写字母
- `[A-Z]`: 匹配任意一个大写字母
- `[0-9]`: 匹配任意数字
- `[^abc]`: 匹配除了a, b或c以外的任意字符
- `\d`: 匹配任意数字
- `\D`: 匹配除了数字以外的任意字符
- `\w`: 匹配任意数字, 字母或下划线
- `\W`: 匹配除了数字, 字母和下划线以外的任意字符
- `\s`: 匹配任意空白字符, 包括空格, 制表符和换行符
- `\S`: 匹配除了空白字符以外的任意字符

### 4. 特殊字符匹配

- `\`: 转译特殊字符
- `|`: 匹配两个或多个分支中的一个
- `()`: 两个作用, 1. 构成整体, 匹配括号内的任意字符, 2. 可以用于捕获组



### 5. 匹配模式

- **贪婪模式**(default): 在可匹配与可不匹配的时候，优先匹配, 比如在`a.*b`中, 中间的`.*`会匹配尽可能多数量的字符, 直到找到最后一个`b`
  - 在找到匹配的内容后,继续向后查找 `/<<.+>>/`
  - 匹配出来: <<阿松大阿萨>> ssss <<啊实打实啊>> 杀杀杀<<Ssss>>
  - 等效于一口将字符串全部吃掉, 再从右边一个个吐出来直到匹配
  - 如果不使用`?`, 直接使用如`.*`则是贪婪匹配

- **惰性模式**: 在可匹配与可不匹配的时候，优先不匹配, 比如`a.*b`中间的`.*`会匹配尽可能少的字符, 找到第一个`b`就结束匹配
  - `/<<.+?>>/`
  - 等效于从左边第一个匹配字符串第一个字符开始的地方,一个一个的吃掉字符串,直到匹配为止
  - 使用`.*?`表示惰性模式下的任意字符匹配

```js
const message = "最重点阿松大, 《阿松大》和 《阿萨》"
// 1. 贪婪模式
const name_1 = /(《.+》)/ig

// 2. 懒惰模式
const name_2 = /(《.+?》)/ig

const iterator = message.matchAll(name_x)
for(const item of iterator){
    connsole.log(item[1])
}
```



### 6. 捕获组:

- `()`将正则中利用括号括起来的内容进行捕获, 捕获的内容何以在matchAll生成的iterator中单独提取,也可以在`match`上单独提取匹配字符串中的一部分
- 也可以使用`()`使其中的内容成为一个整体`/(abc){2,}/` 指abc这个整体出现2次以上

```js
var pattern = /Hello, (\w+)!/; // 匹配Hello, 和 ! 之间的单词
var str = "Hello, world!";
var result = pattern.exec(str);
console.log(result[1]); // 输出world
```



字符串数字 * 数字 = 数字

```js
"123" * 2 = 246
```

