[TOc]

# 内存管理和闭包

## 一. 内存管理

js会自动帮我们管理内存, 像C/C++需要手动的管理内存

- 分配申请需要的内存
- 使用分配的内存
- 不需要使用时, 对其进行释放

js的内存分配:

- JS堆**原始数据类型内存的分配**会在执行时,直接在栈(stack)空间进行分配
- JS对于**复杂数据类型的内存分配**会在堆内存中,开辟一块空间, 并将这块空间的指针返回值变量引用

### 1. Javascript的垃圾回收(GC)

#### 常见的额GC算法:

- 引用计数(Reference counting)

  - 通过一个属性来记录一个对象被引用的次数,当次数为0时,将此空间释放
  - 弊端: 会产生**循环**引用, 两个对象一旦相互引用就很难销毁

- **标记清除(mark - sweep)**

  - **核心思想是可达性**

  - 设置一个根对象, 从这个根对象开始,遍历所有可到达的(被引用)的对象, 对于那些到达不了的对象则视为不可用对象.

  - 可以很好的解决循环引用问题

  - JS里根对象可以设置为GlobalObject(window) -> Root Object
  - **js引擎里用的较为广泛的就是这个算法,当然V8引擎为了进行更好的优化,在算法细节上也会结合一些别的算法**

- 标记整理

  - 和标记清除相似
  - 回收期间会同时保留搬运存储对象到连续的内存空间, 从而整合内存, 避免内存碎片化

- 分代收集

  - 内存空间内对象被分为两组: '新的' 和 '旧的'
  - 将新出现的对象放入新区域,通过频繁检查, 完成工作后就快速清理
  - 那些长期存活下来的对象将会被转到旧区域,对旧区域的检查频率较低

- 增量收集

  - 如果试图遍历一整个对象集, 花费的时间较多, 延迟大
  - 可以将垃圾收集工作分为几部分来做, 然后这几部分会逐一进行处理, 这样可以将大延时转换为许多微小的延时

- 闲时收集

  - 垃圾收集器(GC)只会在CPU空闲时尝试运行, 以减少可能对代码执行的影响



## 二. 闭包

### 1. 闭包介绍

- 闭包在实现上是一个结构体, 它存储了一个函数和一个关联的环境
- 能让我们在内层函数内直接访问外层函数的作用域
- **与作用域链息息相关**(详细见js执行原理
- 函数与他的**出生环境**息息相关



### 2. 闭包内存泄漏:

- 对于那些我们永远不会使用的对象或者函数, 但是对于垃圾处理仍是可达的, 它就不会进行释放, 因此造成内存泄漏
- 需要手动释放, 输入add8 = null, 使其变得不可达,在下次检验时就被垃圾处理回收了

![97542716585736762](.\图片\97542716585736762.png)



#### 浏览器优化:

​	对于你定义的函数中未使用的闭包属性, 浏览器会进行优化, 将其从闭包中删除, 以释放更多空间