[toc]

# 深拷贝和浅拷贝

## 一.引用赋值

```js
const obj = {
    name: "zzt"
}

const info1 = obj
obj.name = "zz"

// info1.name -> "Zz"
```

<img src="./图片/Snipaste_2022-12-13_21-13-06.png" alt="Snipaste_2022-12-13_21-13-06" style="zoom:67%;" />

两个变量保存的是相同的地址信息, 因此通过一个变量改变时, 另一个变量取到的值也会发生变化

## 二. 浅拷贝

会生成一个全新的对象, 但只有第一层的拷贝, 如果一个属性指向一个对象，那么浅拷贝的两个对象的属性都指向相同的内存地址

```js
const obj = {
    name: "zzt"
}

const info = {
    ...obj
}
// 或则 const info = Object.assign({},obj)

info.name = "zz"

// obj.name => "zzt"
```

![Snipaste_2022-12-13_21-23-45](./图片/Snipaste_2022-12-13_21-23-45.png)



## 三. 深拷贝

- 借助一些第三方库
- JSON: `const info = JSON.parse(JSON.stringify(obj))`
  - 对一些特殊的属性不会解析
    - 函数
    - Symbol

  - 不能处理循环引用， 会直接报错

- 自己编写实现(JavaScript暂时没提供深拷贝的方法)

```js
function isObject(value) {
    const valueType = typeof value
    return ( value !== null ) && ( valueType === "object" || valueType === "functioni" )
}

function deepCopy(originValue){
    // 1. 判断当传入的不是对象时, 把原值返回
    if(!isObject(originValue)) return originValue
    //  (优化)判断是否是Set类型的实例
    // if(originValue instanceof Set){
    //			
	//	}
    
    // 2.判断是数组还是对象
    const newObj = Array.isArray(originValue) ? [] : {}
    for (const key in originValue){
        // 3. 这里利用了递归
        newObj[key] = deepCopy(originValue[key])
    }
    return newObj
}
```

```js
// 解决循环引用(一个属性指向对象本身), 伪代码
function deepCopy(originValue, map = new WeakMap()) {
    // if(typeof originValue === "symbol") ...
    
    if(map.get(originValue)){
        return map.get(originValue)
    }
    
    const newObj = Array.isArray(originValue) ? [] : {}
    map.set(originValue,newObj)
    for(const key in originValue){
        newObj[key] = deepCopy(originValue[key],map)
    }
}
```



